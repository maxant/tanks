<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Tanks :: {name ?: "Qute"}</title>
    <style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */
html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
canvas { display:block; } /* To remove the scrollbars */
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
(function() { // https://stackoverflow.com/questions/4288253/html5-canvas-100-width-height-of-viewport
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tanks = [
        buildTank(0, 0, 0, 0, 'green'), // players tank
        buildTank(200, 200, 90, 1, 'blue') // enemy tank
    ];
    const myTank = tanks[0];
    const otherTanks = tanks.filter(t => t !== myTank);
    const dt = 40; // ms; 25 fps
    const tankRadius = 12;

    window.addEventListener('resize', resizeCanvas); // resize the canvas to fill browser window dynamically
    document.addEventListener('keydown', keydown);

    resizeCanvas();

    function buildTank(x, y, direction, speed, colour) {
        return {
            position: { x, y },
            direction,
            colour,
            speed,
            isDead: false,
            dead: function() {
                this.speed = 0;
                this.isDead = true;
            }
        }
    }

    function getScreenCentre(offsetX = 0, offsetY = 0) {
        return {
            x: offsetX + (canvas.width / 2),
            y: offsetY + (canvas.height / 2)
        }
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    }

    function keydown(e) {
        if(myTank.isDead) return;

        if(e.keyCode == 40) { // down => slower
            myTank.speed = Math.max(-5, myTank.speed - 1);
        } else if(e.keyCode == 38) { // up => faster
            myTank.speed = Math.min(10, myTank.speed + 1);
        } else if(e.keyCode == 37) { // left => rotate
            myTank.direction--;
            if(myTank.direction < 0) myTank.direction += 360;
        } else if(e.keyCode == 39) { // right => rotate
            myTank.direction++;
            if(myTank.direction > 359) myTank.direction -= 360;
        } else if(e.keyCode == 32) { // space => full stop
            myTank.speed = 0;
        } else if(e.keyCode == 70) { // F => fire
            myTank.firing = true;
            setTimeout(() => {
                myTank.firing = false;
            }, 100);
        } else {
            console.log("keydown " + e.keyCode);
        }
    }

    function render() {
        moveTanks();
        checkForCrashes();

        // blanken screen
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        // hud
        ctx.save();
        ctx.fillStyle = 'red';
        ctx.font = "12px Arial";
        ctx.fillText("speed: " + myTank.speed, 10, 10);
        ctx.fillText("direction: " + myTank.direction, 10, 20);
        ctx.restore();

        tanks.forEach((tank) => {
            ctx.save();
            const centre = getScreenCentre();
            // translate
            ctx.translate(centre.x, centre.y);
            ctx.translate(tank.position.x, tank.position.y);
            // rotate
            ctx.rotate((Math.PI / 180) * (tank.direction - 90));
            // body
            ctx.fillStyle = tank.colour;
            ctx.beginPath();
            ctx.arc(0, 0, tankRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.fillRect(-2, 0, 5, 2*tankRadius+3); // gun
            ctx.fillRect(-tankRadius-3, -tankRadius, 3, 2*tankRadius); // tracks
            ctx.fillRect(+tankRadius, -tankRadius, 3, 2*tankRadius); // tracks

            if(tank.isDead) {
                ctx.fillStyle = 'orange';
                ctx.font = "48px Arial";
                let txt = "X";
                let metrics = ctx.measureText(txt);
                let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                ctx.fillText(txt, -metrics.width/2, +actualHeight/2);
            } else { // still alive
                if(tank.firing) {
                    const endOfFireX = (canvas.width+canvas.height) * Math.cos(tank.direction * Math.PI / 180);
                    const endOfFireY = (canvas.width+canvas.height) * Math.sin(tank.direction * Math.PI / 180);
                    tanks.forEach((otherTank) => {
                        if(tank !== otherTank) {
                            if(lineInterceptsCircle(tank.position.x,
                                                    tank.position.y,
                                                    endOfFireX,
                                                    endOfFireY,
                                                    otherTank.position.x,
                                                    otherTank.position.y,
                                                    tankRadius)){
                                otherTank.dead();
                            }
                        }
                    });
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-1, 2*tankRadius+5, 3, canvas.width + canvas.height); // width+height to be on the safe side
                }
            }
            ctx.restore();
        });
    }

    // https://math.stackexchange.com/a/275537
    // parameters: ax ay (end of line or actually center of tank), bx by (other end of line), cx cy r (circle posn & radius)
    function lineInterceptsCircle(ax, ay, bx, by, cx, cy, r) {
        ax -= cx;
        ay -= cy;
        bx -= cx;
        by -= cy;
        const a = (bx - ax)**2 + (by - ay)**2;
        const b = 2*(ax*(bx - ax) + ay*(by - ay));
        const c = ax**2 + ay**2 - r**2;
        const disc = b**2 - 4*a*c;
        if(disc <= 0) return false;
        const sqrtdisc = Math.sqrt(disc);
        const t1 = (-b + sqrtdisc)/(2*a);
        const t2 = (-b - sqrtdisc)/(2*a);
        return (0 < t1 && t1 < 1) || (0 < t2 && t2 < 1);
    }

    function checkForCrashes() {

        // https://www.geeksforgeeks.org/check-two-given-circles-touch-intersect/
        function circlesIntersect(x1, y1, x2, y2, r1, r2) {
            let distSq = Math.sqrt( (x1 - x2) * (x1 - x2) +
                                    (y1 - y2) * (y1 - y2) );
            let radSum = (r1 + r2);
            return distSq <= radSum;
        }

        tanks.forEach(t1 => {
            tanks.forEach(t2 => {
                if(t1 !== t2) {
                    if(circlesIntersect(t1.position.x, t1.position.y, t2.position.x, t2.position.y, tankRadius, tankRadius) > 0) {
                        t1.dead();
                        t2.dead();
                    }
                }
            });
        });
    }

    function moveTanks() {
        tanks.forEach(tank => {
            // speed = distance / time => distance = speed * time; time = 100;
            const distance = tank.speed * dt / 100; // 100 is a factor to slow everything down!
            tank.position.x += distance * Math.cos(tank.direction * Math.PI / 180);
            tank.position.y += distance * Math.sin(tank.direction * Math.PI / 180);
        });

        // now reset relative to mine, so mine stays in the middle of the screen
        otherTanks.forEach(tank => {
            tank.position.x -= myTank.position.x;
            tank.position.y -= myTank.position.y;
        });
        myTank.position.x = 0;
        myTank.position.y = 0;
    }

    setInterval(render, dt);
})();

// TODO
// - add points
// - limit how many shots you have
// - add weapons cache
// - add fuel and fuel cache
// - add health and reduce it depending on weapon
// - add weapons
// - how to get backend to validate positions? or do the calcs in the backend, based on the input controls provided by the front end?
// - stop gently
// - add ground texture - add repeating tiles
// - ai for other tanks
// - shields and their damage
// - "radar" on edge of screen, to show tanks that are off screen, with distance to them
</script>
</body>
</html>
